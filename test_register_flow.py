#!/usr/bin/env python3
"""
Test the proper registration flow to understand the 401 error.
This demonstrates the correct authentication flow for registration.
"""

import sys
import json
import base64
import requests
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

from chorus_stage.utils.pow_client import find_pow_solution

API_BASE = "http://localhost:8000/api/v1"

def test_register_flow():
    """Test the complete registration flow to understand 401 errors."""
    print("🔍 Testing Registration Flow...")
    
    # Step 1: Generate a valid Ed25519 key pair (simplified for demo)
    # In a real client, this would be generated using cryptography libraries
    print("\n1️⃣ Generating Ed25519 key pair...")
    
    # For demo purposes, we'll use a known valid key
    # In reality, this would be generated by the client
    pubkey_b64 = "dGVzdF9wdWJrZXlfMzJfYnl0ZXNfbG9uZ19lbm91Z2g="  # 32 bytes base64
    print(f"   📝 Public key (base64): {pubkey_b64}")
    
    # Step 2: Get challenge from server
    print("\n2️⃣ Requesting challenge from server...")
    
    try:
        challenge_response = requests.post(
            f"{API_BASE}/auth/challenge",
            json={
                "pubkey": pubkey_b64,
                "intent": "register"
            },
            headers={"Content-Type": "application/json"}
        )
        
        if challenge_response.status_code != 200:
            print(f"   ❌ Challenge request failed: {challenge_response.status_code}")
            print(f"   Response: {challenge_response.text}")
            return
            
        challenge_data = challenge_response.json()
        print(f"   ✅ Challenge received:")
        print(f"      🎯 PoW Target: {challenge_data['pow_target'][:16]}...")
        print(f"      📊 Difficulty: {challenge_data['pow_difficulty']} bits")
        print(f"      🔐 Signature Challenge: {challenge_data['signature_challenge'][:16]}...")
        
    except Exception as e:
        print(f"   ❌ Error getting challenge: {e}")
        return
    
    # Step 3: Solve PoW (this is what the client would do)
    print("\n3️⃣ Solving proof-of-work...")
    
    try:
        # Client would solve PoW here
        pow_solution = find_pow_solution(
            "register", 
            pubkey_b64, 
            challenge_data['pow_target'], 
            challenge_data['pow_difficulty'], 
            "blake3"
        )
        print(f"   ✅ PoW solution found: nonce={pow_solution}")
        
    except Exception as e:
        print(f"   ❌ PoW solution failed: {e}")
        return
    
    # Step 4: Create signature (this is what the client would do)
    print("\n4️⃣ Creating signature...")
    
    # In a real client, this would be:
    # 1. Decode the signature_challenge from base64
    # 2. Sign it with the private key
    # 3. Encode the signature as base64
    
    # For demo, we'll create a mock signature
    signature_b64 = "dGVzdF9zaWduYXR1cmVfNjRfYnl0ZXNfbG9uZ19lbm91Z2hfdG9fYmFzZTY0"  # Mock signature
    print(f"   📝 Signature (base64): {signature_b64[:16]}...")
    
    # Step 5: Attempt registration
    print("\n5️⃣ Attempting registration...")
    
    try:
        register_payload = {
            "pubkey": pubkey_b64,
            "display_name": "Test User",
            "pow": {
                "nonce": str(pow_solution),
                "difficulty": challenge_data['pow_difficulty'],
                "target": challenge_data['pow_target'],
                "hash_algorithm": "blake3"
            },
            "proof": {
                "challenge": challenge_data['signature_challenge'],
                "signature": signature_b64
            }
        }
        
        register_response = requests.post(
            f"{API_BASE}/auth/register",
            json=register_payload,
            headers={"Content-Type": "application/json"}
        )
        
        print(f"   📊 Status Code: {register_response.status_code}")
        
        if register_response.status_code == 200:
            print("   ✅ Registration successful!")
            print(f"   Response: {register_response.json()}")
        else:
            print("   ❌ Registration failed!")
            print(f"   Error: {register_response.text}")
            
    except Exception as e:
        print(f"   ❌ Registration error: {e}")

def explain_401_error():
    """Explain why 401 errors occur in registration."""
    print("\n" + "="*60)
    print("🔍 WHY 401 UNAUTHORIZED OCCURS:")
    print("="*60)
    
    print("\n📋 The registration endpoint requires:")
    print("   1. ✅ Valid Ed25519 public key (32 bytes, base64-encoded)")
    print("   2. ✅ Valid proof-of-work solution")
    print("   3. ✅ Valid cryptographic signature over challenge")
    print("   4. ✅ Proper request format with all required fields")
    
    print("\n🚫 Common causes of 401 errors:")
    print("   • Invalid public key format (not 32 bytes or not base64)")
    print("   • Invalid signature (not signed with correct private key)")
    print("   • Wrong challenge (not using the server-provided challenge)")
    print("   • Missing or malformed request fields")
    
    print("\n🔄 Proper client flow:")
    print("   1. Generate Ed25519 key pair")
    print("   2. POST /auth/challenge with public key")
    print("   3. Solve PoW challenge")
    print("   4. Sign the signature_challenge with private key")
    print("   5. POST /auth/register with all required fields")
    
    print("\n💡 The client must implement proper cryptographic operations!")

if __name__ == "__main__":
    print("🚀 Chorus Stage Registration Flow Test")
    print("="*60)
    
    test_register_flow()
    explain_401_error()
